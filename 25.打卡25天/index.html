<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        p{
            color: red;
        }
    </style>
</head>
<body>
    <p>bind介绍</p>
    bind(context,arguments) 返回一个函数 <hr>
    <p>call介绍</p>
    call(context,arg1,arg2...) 指定作用域 同时执行函数 <hr>
    <p>apple介绍</p>
    apply(context,args) 指定作用域 同时执行函数，后面的参数是数组 <hr>
    <p>三者区别</p>
    call和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同。
    除了第一个参数外，call可以接收一个参数列表，apply只接受一个参数数组。 bind绑定完之后返回一个新的函数，不执行。<hr>
</body>
<script>
    //this
    var mh={
        a: function(){
            var _this =this; //通过复制到方式将this赋值给_this
            var func =function(){
                console.log(this.c);
                console.log(_this.c)
            }
            func();
        },
        b: function(){
            var func1 =function(){
                console.log(this.c);
            }.bind(this);
            func1();
        },
        d: function(){
            var func2=function(){
                console.log(this.c);
            };
            func2.bind(this)();
        },
        c:"hello"
        
    }
    mh.a(); //undefined  此时的this是全局作用域的，并没有赋值
    mh.b(); //bind的第一钟方法
    mh.d(); //bind第二种方法

    Function.prototype.my_bind = function() {
      var self = this, // 保存原函数
        context = Array.prototype.shift.call(arguments), // 保存需要绑定的this上下文
        // 上一行等价于 context = [].shift.call(arguments);
        args = Array.prototype.slice.call(arguments); // 剩余的参数转为数组
      return function() { // 返回一个新函数
        self.apply(context, Array.prototype.concat.call(args, Array.prototype.slice.call(arguments)));
      }
    }
  function a(m, n, o) {
    console.log(this.name + ' ' + m + ' ' + n + ' ' + o);
  }
  var b = {
    name: 'menghui'
  };
  a.my_bind(b, 7, 8)(9); // kong 7 8 9
</script>
</html>